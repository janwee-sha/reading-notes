# 加入操作系统实现多程序原因

*   资源利用率
*   公平性
*   便利性

# 线程带来的风险

*   安全性问题
*   活跃性问题
*   性能问题

# 线程安全性

*   无状态对象一定是线程安全的。

# 内置锁

*   Java提供了一种内置的锁机制来支持原子性--同步代码块。
*   内置锁是可重入的（线程试图获得一个已经由它自己持有的锁）。

# 活跃性与性能

*   简单性和性能之间通常存在着相互制约因素

# 可见性

*   在线程间共享变量时，若没有使用正确的同步，可能会导致可见性问题。
*   加锁的含义不仅仅局限于互斥行为，还包括内存可见性。

# 非原子的64位操作

*   非volatile的long、double变量即使不考虑失效数据问题，在多线程中使用共享且可变操作也是不安全的。

# Volatile变量

*   一种稍弱的同步机制，用以确保将变量的更新操作通知到其他线程。
*   加锁机制可同时保证可见性、原子性，volatile变量只能确保可见性。

# 安全的对象构造过程

*   不要在对象构造过程中使this引用逸出。

# 线程封闭

## Ad-hoc线程封闭

*   维护线程封闭性的职责完全由程序实现来承担。

## 栈封闭

*   也被称为线程内部使用或者线程局部使用，只能通过局部变量才能访问对象。

## ThreadLocal类

# 不变性

## 不可变对象一定是线程安全的。

## 不可变性必要条件

*   对象创建后其状态就不能修改
*   对象的所有域都是final类型
*   对象是正确创建的（对象创建期间this引用没有逸出）

# 安全发布对象

## 常用模式

*   在静态初始化函数中初始化一个对象引用(静态初始化器由JVM在类的初始化阶段执行，JVM内部存在同步机制，因此可以安全发布)

如：public static Thing thing=new Thing();

*   将对象的引用保存大volatile类型的域或者AtomicReference对象中
*   将对象的引用保存到某个正确构造的final类型域中
*   将对象的引用保存到一个由锁保护的域中

# 并发程序中使用和共享对象的实用策略

*   线程封闭
*   只读共享
*   线程安全共享
*   保护对象

# 中断线程

*   调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。
*   通常，中断是实现取消最合理的方式。
*   当调用可中断的阻塞函数时，有两种实用策略可用于处理InterruptException：传递异常，是你的方法也成为可中断的阻塞方法；恢复中断状态，使调用栈的上层代码能够对其进行处理。
*   只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。

# 守护线程

*   用以执行一些辅助工作且不阻碍JVM关闭的线程即是守护线程。
*   应尽可能少的使用守护线程（因为很少有操作能在不进行清理的情况下被安全地抛弃）。

# 需要明确指定执行策略的任务类型

*   依赖性任务--要求线程池足够大
*   使用线程封闭机制的任务--串行执行
*   对响应时间敏感的任务--要求线程池足够大
*   使用ThreadLocal的任务--不应该在线程池的线程中使用ThreadLocal传递值

# ThreadPoolExecutor的饱和策略

ThreadPoolExecutor用以应对有界队列被填满的情况的策略。

*   Abort（中止）

默认的饱和策略，将抛出未检查的RejectedExecutionException。

*   Caller-Runs（调用者运行）

既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。

# 通过Executors除newSingleThreadExecutor外的工厂方法可转型为ThreadPoolEexecutor再修改线程池配置

# 活跃性故障

## 死锁

指线程间互相请求资源形成环路而无法继续执行的情况。

*   锁顺序死锁
*   动态的锁顺序死锁
*   通过锁顺序来避免死锁

## 饥饿

指线程由于无法访问它所需要的资源而不能继续执行的情况。

## 糟糕的响应性

指某个线程长时间占有一个锁，其他线程需要等待很久才能被执行的情况。

## 活锁

指线程不断重复执行相同的操作而且总会失败，导致尽管不会阻塞线程，但也不能继续执行的情况。

## 丢失信号

指线程必须等待一个已经为真的条件，但在开始等待之前没有检查条件谓词的情况。

# 并发程序的测试

## 与活跃性相关的测试是性能测试，包括

*   吞吐量：一组并发任务中已完成任务所占的比例。
*   响应性：请求从发出到完成之间的事件。
*   可伸缩性：当增加计算资源（CPU、内存、存储容量或I/O带宽等）时，程序的吞吐量和处理能力能相应地增加。

# 显式锁

*   与内置加锁机制不同的是，Lock提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，加锁解锁方式都是显式的。

# 线程引入的开销

*   上下文切换

可运行的线程数大于CPU的数量时，操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU。

*   内存同步
*   阻塞

# 减少锁的竞争

在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。
有3种方式可以降低锁的竞争程度：

*   减少锁的持有时间；
*   降低锁的请求频率；
*   是由带有协调机制的独占锁，这些机制允许更高的并发性。

# 并发程序的测试

## 正确性测试

*   基本的单元测试

验证后验条件和不变性条件

*   阻塞操作的测试

在测试方法的阻塞行为是，将引入额外的复杂性：当方法被成功阻塞后，还必须使方法解除阻塞。
超时机制能确保测试最终完成。

*   安全性测试
*   资源管理的测试
*   使用回调

