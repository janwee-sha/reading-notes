# 1. 走近Java

## 1.2 Java技术体系

JCP官方所定义的Java技术体系包括以下部分：

- Java程序设计语言
- 各种硬件平台上的Java虚拟机实现
- Class文件格式
- Java类库API
- 来自商业机构和开源社区的第三方Java类库

<To be continued>

# 2. Java内存区域与内存溢出异常

## 2.1 概述

在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和溢出方面的问题。

## 2.2 运行时数据区域

Java虚拟机的运行时数据区：

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.1.png)

### 2.2.1 程序计数器

Program Counter Register是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都会执行一条程序中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，即“线程私有”的内存。

如果正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的位置；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。

此区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

### 2.2.2 Java虚拟机栈

Java Virtual Machine Stack也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行时，虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型和returnAddress类型（指向了一条字节码指令的地址）。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，64位长度的long和double类型的数据会占用两个变量槽，其余只占用一个。

在《Java虚拟机规范》中，对Java虚拟机栈规定了两类异常状况：若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；若Java虚拟机栈无法申请到足够的内存会抛出OutOfMemoeyError异常。

### 2.2.3 本地方法栈

Native Method Stack与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也即字节码）服务，而本地方法栈则是为虚拟机使用到的本地方法服务。
该区域规定的异常情况与虚拟机栈一样。

### 2.2.4 Java堆

对于Java应用来说。Java Heap是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，Java世界里几乎所有的对象实例都在这里分配内存。

Java堆是垃圾收集管理的内存区域，因此一些资料中它也被称为GC堆。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”、“老年代”、“永久代”、“Eden空间”等名词。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。若Java队中没有内存完成实例分配，且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemory异常。

### 2.2.5 方法区

Method Area与Java堆一样，是线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。垃圾收集行为在这个区域相对而言较少出现。该区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

根据《Java虚拟机规范》的规定，方法区无法满足新的内存分配需求时，将抛出OutOfMemory异常。

### 2.2.6 运行时常量池

Runtime Constant Pool是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容加载类加载后存放到方法区的运行时常量池中。

当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

### 2.2.7 直接内存

Direct Memory并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。这部分区域也可能会出现OOM异常。

JDK 1.4中加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储再Java堆里面的DirectByteBuffer对象作为这块内存的引用操作。在某些场景中能显著提升性能，因为避免了在Java堆与Native堆中来回复制数据。动态拓展时可能会出现OOM异常。

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

**对象创建的过程**：

1. Java虚拟机遇到一条字节码 `new` 指令时，首先检查指令的参数是否能在常量池中定位到一个类的符号引用，且检查该符号引用代表的类是否已被加载、解析和初始化过。若没有，那么先执行相应的类加载过程。
2. 类加载检查通过后，接着虚拟机将为新生对象分配内存。对象所需内存在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。
3. 内存分配完成后，虚拟机必须将分配到的内存空间都初始化为零值。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。
4. 接着，Java虚拟机还要对对象进行必要的设置，如该对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用 `Object::hashCode()` 方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。
5. 上述工作完成表示虚拟机的工作结束了，但Java程序需要根据构造函数，即Class文件中的 `<init>()` 方法将对象构造出来。

### 2.3.2 对象的内存布局

在Hotspot虚拟机中，对象在堆内存中的存储布局可划分为对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）三个部分。

1. **对象头**——Hotspot虚拟机的对象头部分包含两类信息。第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别位32比特和64比特，官方称它为“Mark Word”。第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并非所有的虚拟机实现都必须要经过对象本身。此外，若对象是一个Java数组，那么对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但若数组长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

2. **实例数据**——对象真正存储的有效信息，即各字段内容。

3. **对齐填充**——并非必然存在，也没有特别的含义。

### 2.3.3 对象的访问定位

《Java虚拟机规范》里面只规定了reference类型是一个指向对象的引用，对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：

- **句柄访问**。Java堆中可能会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自具体的地址信息。

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.2.png)

- **直接指针访问**。Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址。

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.3.png)

句柄访问的优势是reference中存储的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

直接指针访问的好处是速度更快，它节省了一次指针定位的时间开销。HotSpot使用了第二种方式进行对象访问。

## 2.4 实战：OutOfMemoryError异常

### 2.4.1 Java堆溢出

Java堆用于存储对象实例，只要不断地创建对象，且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

[这里](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/HeapOOM.java)的代码限制Java堆的大小为20MB，不可扩展（将堆的最小值 `-Xms` 参数与最大值 `-Xmx` 参数设置为一样即可避免堆自动扩展），参数 `-XX:+HeapDumpOnOutOfMemoryError` 可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便进行事后分析。

若是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与那些GC Roots相关联，才导致垃圾收集器无法回收它们。

若非内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数设置，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行时的内存消耗。

### 2.4.2 虚拟机栈和本地方法栈溢出

由于HotSpot虚拟机并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，`-Xoss` 参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由 `-Xss` 参数来设定。

《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展。除非在创建线程申请内存时就因无法获得足够内存而出现 `OutOfMemoryError` 异常，否则在线程运行时是不会因扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致 `StackOverflowError` 异常。

下面将实验范围限制在单线程内操作，尝试下面两个行为是否能让HotSpot虚拟机产生 `OutOfMemoryError` 异常：

- 使用 `-Xss` 参数减少栈内存容量。点击[这里](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/JavaVMStackSOF.java)查看代码。

- 定义大量的本地变量，增大此方法帧中本地变量表的长度。点击[这里](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/JavaVMStackSOF2.java)查看代码。

在HotSpot虚拟机下，两个实验都抛出 `StackOverflowError` 异常。可是如果在允许动态扩展栈容量大小的虚拟机上，相同代码会导致不一样的情况。

### 2.4.3 方法区和运行时常量池溢出

**运行时常量池**

HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代。

在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 限制永久代的大小，即可间接限制其中容量池的容量，具体实现如[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/RuntimeConstantPoolOOM.java)的代码所示。

在JDK 6中运行上述代码会抛出 `OutOfMemoryError` 异常且紧跟着的提示信息是“PermGen space”，说明运行时常量池的确是属于方法区（即JDK 6的HotSpot虚拟机中的永久代）的一部分。

而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使用 `-XX:MaxPermSize` 参数或者在JDK 8及以上版本使用 `-XX:MaxMetaspaceSize` 参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将会一直进行下去，永不停歇。这是因为自JDK 7起，原本存放在永久代的字符串常量被移至Java堆中。因此在JDK 7及以上版本，限制方法区的容量对改测试用例来说毫无意义。这时候使用 `-Xmx` 参数限制最大堆到6MB就能够抛出 `OutOfMemoryError` 异常。

**方法区**

对于方法区溢出的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出为止。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。

[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/JavaMethodAreaOOM.java) 的代码借助了CGLib直接操作字节码运行时生成了大量的动态类。

方法区溢出也是一种常见的内存溢出异常，一个类若要被垃圾收集器回收，要达成的条件是比较苛刻的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。

在JDK 8以后，永久代便被元空间代替。默认设置下，前述那些正常的动态创建新类型的测试用例已经很难再使虚拟机产生方法区的溢出异常了。但HotSpot还是提供了一些元空间相关的JVM参数：

- `-XX: MaxMetaspaceSize`：设置元空间最大值，默认是 `-1`，即不限制。
- `-XX: MetaspaceSize`：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：若释放了大量的空间，就适当降低该值；若释放了很少的空间，那么在不超过 `-XX: MaxMetaspaceSize` 的情况下，适当提高该值。
- `-XX: MinMetaspaceFreeRatio`：在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。

### 2.4.4 本机直接内存溢出

Direct Memory的容量大小可通过 `-XX:MaxDirectMemorySize` 参数来指定，若不去指定，则默认与Java堆最大值一致。

[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/DirectMemoryOOM.java) 的代码越过了 `DirectByteBuffer` 类通过反射获取 `Unsafe` 实例进行内存分配，因为虽然使用 `DirectByteBuffer` 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配就会在代码里手动排除溢出异常，真正申请分配内存的方法是 `Unsafe:: allocateMemory()`。

由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，若发现内存溢出之后产生的Dump文件很小，而程序又直接或间接地适用了DirectMemory，那就可以考虑重点检查一下直接内存方面的原因了。

# 3. 垃圾收集器与内存分配策略

## 3.1 概述

垃圾收集需要完成的三件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

程序计数器、虚拟机栈、本地方法栈的内存分配和回收都具备确定性。当方法结束或线程结束时，内存就跟着被回收了。

Java堆和方法区的内存分配和回收则有着不确定性，这些部分的内存分配和回收是动态的。垃圾收集器所关注的正式这部分内存该如何管理。

## 3.2 对象已死？

### 3.2.1 引用计数算法

在对象中添加一个引用计数器，每有一处引用它时，计数器值加一；每有引用失效时，计数器值减一。任何时刻计数器为零的对象就是不可能再被使用的。

**Reference Counting算法**原理简单，判定效率也高，多数情况下是一个不错的算法。但主流的java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须配合大量额外的工作才能保证正确工作，如单纯的引用计数就很难解决对象之间相互循环引用的问题。

### 3.2.2 可达性分析算法

当前主流的商用程序语言（Java、C#、Lisp
）的内存管理子系统，都是通过可达性分析（Reachablility Analysis）算法来判断对象是否存活的。基本思路是通过一系列称为“GC Roots”的跟对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中所走过的路径被称为“引用链”，若某对象到GC Roots间没有任何引用链相连则证明此对象是不可能再被使用的。

在Java技术体系里，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，如线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

- 在方法区中类静态属性引用的对象，如Java类的引用类型静态变量。

- 在方法区中常量引用的对象，如字符串常量池里的引用。

- 在本地方法栈中JNI（即Native方法）引用的对象。

- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如NullPointerException、OutOfMemoryError）等，还有系统类加载器。

- 所有被同步锁持有的对象。

- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 3.2.3 再谈引用

在JDK 1.2版之前，Java里面的引用是很传统的定义：若reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。对象在这种定义下只有被引用和未被引用的两种状态。

在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为Strongly Reference、Soft Reference、Weak Reference、Phantom Reference 4种，这4种引用强度依次逐渐减弱。

- **强引用**。最传统的“引用”的定义，是指代码中普遍存在的引用赋值，即类似Object obj = new Object()这种引用关系。无论何种情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- **软引用**。用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，若这次回收还没有足够的内存，才会抛出内存溢出异常。
- **弱引用**。用来描述哪些非必须对象，但其强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
- **虚引用**。也称为”幽灵引用“或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

### 3.2.4 生存还是死亡？

即使在可达性分析算法中判定为不可达的对象，要真正宣告一个对象死亡，至少要经历两次标记过程：若对象被判定为不可达对象后，它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize()` 方法。假如对象没有覆盖 `finalize()` 方法，或者 `finalize()` 方法已经被虚拟机调用过,那么虚拟机将这两种情况都视为“没有必要执行”。

若对象被判定为有必要执行 `finalize()` 方法，该对象将会被放置在一个名为*F-Queue*的队列之中，并在稍后由一条虚拟机自动建立的、低调度优先级的*Finalizer*线程去执行 `finalize()` 方法。稍后收集器对*F-Queue*中的对象进行第二次标记，若对象在 `finalize()` 方法中重新被引用，那么第二次标记时它将会被移出“即时回收”的集合；否则对象真的要被回收了。

[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter3/FinalizeEscapeGC.java) 的代码演示了一个对象的自我拯救。

## 3.3 垃圾收集算法

从如何判定对象消亡的角度出发，垃圾收集算法可以被划分为“引用计数式垃圾收集”和“跟踪式垃圾收集”两大类。本节介绍的算法均属于跟踪式垃圾收集的范畴。

### 3.3.1 分代收集理论

分代收集理论建立在两个分代假说之上：

- 弱分代假说：绝大多数对象都是朝生夕灭的。
- 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。

这两个假说共同奠定了主流垃圾收集器的一致设计原则：收集器应该将Java堆划分为不同的区域，然后将回收对象依据其年龄（熬过垃圾收集过程的次数）分配到不同的区域之中存储。若一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收只关注少量存活而不是去标记大量将要被回收的对象，就能以较低代价回收大量的空间；若剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域。兼顾垃圾收集的时间开销和内存空间的有效利用。

在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收部分区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对对象存亡特征安排不同的垃圾收集算法。

把分代收集理论具体放到现在的商用虚拟机里，设计者一般至少会把Java堆划分为为新生代和老年代两个区域。

分代收集并非只是简单地划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会跨代引用。

为了解决这个问题，就需要堆分代收集理论添加第三条经验法则：

跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

依据该假说，我们不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构将老年代划分成若干小块，标识出老年代的那一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

# 7. 虚拟机加载机制

代码编译的结果是从本地机器码转变为字节码。

## 7.1 概述

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载过程。

## 7.2 类加载时的机制

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载七个阶段，其中验证、准备、解析三个阶段统称为连接（Linking）。