# 1. 走近Java

## 1.2 Java技术体系

JCP官方所定义的Java技术体系包括以下部分：

- Java程序设计语言
- 各种硬件平台上的Java虚拟机实现
- Class文件格式
- Java类库API
- 来自商业机构和开源社区的第三方Java类库

# 2. Java内存区域与内存溢出异常

## 2.1 概述

在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和溢出方面的问题。

## 2.2 运行时数据区域

Java虚拟机的运行时数据区：

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.1.png)

### 2.2.1 程序计数器

Program Counter Register是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都会执行一条程序中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，即“线程私有”的内存。

如果正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的位置；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。

此区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

### 2.2.2 Java虚拟机栈

Java Virtual Machine Stack也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行时，虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型和returnAddress类型（指向了一条字节码指令的地址）。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，64位长度的long和double类型的数据会占用两个变量槽，其余只占用一个。

在《Java虚拟机规范》中，对Java虚拟机栈规定了两类异常状况：若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；若Java虚拟机栈无法申请到足够的内存会抛出OutOfMemoeyError异常。

### 2.2.3 本地方法栈

Native Method Stack与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也即字节码）服务，而本地方法栈则是为虚拟机使用到的本地方法服务。
该区域规定的异常情况与虚拟机栈一样。

### 2.2.4 Java堆

对于Java应用来说。Java Heap是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，Java世界里几乎所有的对象实例都在这里分配内存。

Java堆是垃圾收集管理的内存区域，因此一些资料中它也被称为GC堆。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”、“老年代”、“永久代”、“Eden空间”等名词。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。若Java队中没有内存完成实例分配，且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemory异常。

### 2.2.5 方法区

Method Area与Java堆一样，是线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。垃圾收集行为在这个区域相对而言较少出现。该区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

根据《Java虚拟机规范》的规定，方法区无法满足新的内存分配需求时，将抛出OutOfMemory异常。

### 2.2.6 运行时常量池

Runtime Constant Pool是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容加载类加载后存放到方法区的运行时常量池中。

当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

### 2.2.7 直接内存

Direct Memory并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。这部分区域也可能会出现OOM异常。

JDK 1.4中加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储再Java堆里面的DirectByteBuffer对象作为这块内存的引用操作。在某些场景中能显著提升性能，因为避免了在Java堆与Native堆中来回复制数据。动态拓展时可能会出现OOM异常。

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

**对象创建的过程**：

1. Java虚拟机遇到一条字节码 `new` 指令时，首先检查指令的参数是否能在常量池中定位到一个类的符号引用，且检查该符号引用代表的类是否已被加载、解析和初始化过。若没有，那么先执行相应的类加载过程。
2. 类加载检查通过后，接着虚拟机将为新生对象分配内存。对象所需内存在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。
3. 内存分配完成后，虚拟机必须将分配到的内存空间都初始化为零值。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。
4. 接着，Java虚拟机还要对对象进行必要的设置，如该对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用 `Object::hashCode()` 方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。
5. 上述工作完成表示虚拟机的工作结束了，但Java程序需要根据构造函数，即Class文件中的 `<init>()` 方法将对象构造出来。

### 2.3.2 对象的内存布局

在Hotspot虚拟机中，对象在堆内存中的存储布局可划分为对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）三个部分。

1. **对象头**——Hotspot虚拟机的对象头部分包含两类信息。第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别位32比特和64比特，官方称它为“Mark Word”。第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并非所有的虚拟机实现都必须要经过对象本身。此外，若对象是一个Java数组，那么对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但若数组长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

2. **实例数据**——对象真正存储的有效信息，即各字段内容。

3. **对齐填充**——并非必然存在，也没有特别的含义。

### 2.3.3 对象的访问定位

《Java虚拟机规范》里面只规定了reference类型是一个指向对象的引用，对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：

- **句柄访问**。Java堆中可能会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自具体的地址信息。

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.2.png)

- **直接指针访问**。Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址。

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.3.png)

句柄访问的优势是reference中存储的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

直接指针访问的好处是速度更快，它节省了一次指针定位的时间开销。HotSpot使用了第二种方式进行对象访问。

# 3. 垃圾收集器与内存分配策略

## 3.1 概述

垃圾收集需要完成的三件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

## 3.2 对象已死？

### 3.2.1 引用计数算法

在对象中添加一个引用计数器，每有一处引用它时，计数器值加一；每有引用失效时，计数器值减一。任何时刻计数器为零的对象就是不可能再被使用的。

引用计数算法原理简单，判定效率也高，多数情况下是一个不错的算法。但主流的java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须配合大量额外的工作才能保证正确工作，如单纯的引用计数就很难解决对象之间相互循环引用的问题。

### 3.2.2 可达性分析算法

当前主流的商用程序语言的内存管理子系统，都是通过可达性分析（Reachablility Analysis）算法来判断对象是否存活的。基本思路是通过一系列称为“GC Roots”的跟对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中所走过的路径被称为“引用链”，若某对象到GC Roots间没有任何引用链相连则证明此对象是不可能再被使用的。

在Java计数体系里，固定可作为GC Roots的对象包括以下几种：

在虚拟机栈（栈帧中的本地变量表）中引用的对象，如线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

在方法区中类静态属性引用的对象，如Java类的引用类型静态变量。

在方法区中常量引用的对象，如字符串常量池里的引用。

在本地方法栈中Native方法引用的对象。

Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如NullPointerException、OutOfMemoryError）等，还有系统类加载器。

所有被同步锁持有的对象。

反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
### 3.2.3 再谈引用

在JDK 1.2版之前，Java里面的引用是很传统的定义：若reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。

在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次逐渐减弱。

- 强引用是最传统的“引用”的定义，是指代码中普遍存在的引用赋值，即类似Object obj = new Object()这种引用关系。无论何种情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，若这次回收还没有足够的内存，才会抛出内存溢出异常。
- 弱引用也是用来描述哪些非必须对象，但其强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
- 虚引用也称为”幽灵引用“或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

### 3.2.4 生存还是死亡？

即使在可达性分析算法中判定为不可达的对象，它们会先处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：若对象被判定为不可达对象后，它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法（对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过）。若是，该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低调度优先级的Finalizer线程去执行finalize()方法。稍后收集器对F-Queue中的对象进行第二次标记，若对象在finalize方法中重新被引用，那么第二次标记时它将会被移出“即时回收”的集合；否则对象真的要被回收了。

## 3.3 垃圾收集算法

从如何判定对象消亡的角度出发，垃圾收集算法可以被划分为“引用计数式垃圾收集”和“跟踪式垃圾收集”两大类。本节介绍的算法均属于跟踪式垃圾收集的范畴。

### 3.3.1 分代收集理论

分代收集理论建立在两个分代假说之上：

- 弱分代假说：绝大多数对象都是朝生夕灭的。
- 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。

这两个假说共同奠定了主流垃圾收集器的一致设计原则：收集器应该将Java堆划分为不同的区域，然后将回收对象依据其年龄（熬过垃圾收集过程的次数）分配到不同的区域之中存储。若一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收只关注少量存活而不是去标记大量将要被回收的对象，就能以较低代价回收大量的空间；若剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域。兼顾垃圾收集的时间开销和内存空间的有效利用。

在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收部分区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对对象存亡特征安排不同的垃圾收集算法。

把分代收集理论具体放到现在的商用虚拟机里，设计者一般至少会把Java堆划分为为新生代和老年代两个区域。

分代收集并非只是简单地划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会跨代引用。

为了解决这个问题，就需要堆分代收集理论添加第三条经验法则：

跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

依据该假说，我们不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构将老年代划分成若干小块，标识出老年代的那一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

# 7. 虚拟机加载机制

代码编译的结果是从本地机器码转变为字节码。

## 7.1 概述

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载过程。

## 7.2 类加载时的机制

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载七个阶段，其中验证、准备、解析三个阶段统称为连接（Linking）。