> 摘抄自[周志明.深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）北京华章图文信息有限公司.Kindle 版本](https://www.amazon.cn/dp/B082PTTSNB/ref=sr_1_1?crid=117XJLCB8Y06O&keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA&qid=1677240608&s=digital-text&sprefix=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2Cdigital-text%2C104&sr=1-1)

# 1. 走近Java

## 1.2 Java技术体系

JCP官方所定义的Java技术体系包括以下部分：

- Java程序设计语言
- 各种硬件平台上的Java虚拟机实现
- Class文件格式
- Java类库API
- 来自商业机构和开源社区的第三方Java类库

<To be continued>

# 2. Java内存区域与内存溢出异常

## 2.1 概述

在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和溢出方面的问题。

## 2.2 运行时数据区域

Java虚拟机的运行时数据区：

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.1.png)

### 2.2.1 程序计数器

Program Counter Register是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都会执行一条程序中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，即“线程私有”的内存。

如果正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的位置；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。

此区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

### 2.2.2 Java虚拟机栈

Java Virtual Machine Stack也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行时，虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型和returnAddress类型（指向了一条字节码指令的地址）。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，64位长度的long和double类型的数据会占用两个变量槽，其余只占用一个。

在《Java虚拟机规范》中，对Java虚拟机栈规定了两类异常状况：若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；若Java虚拟机栈无法申请到足够的内存会抛出OutOfMemoeyError异常。

### 2.2.3 本地方法栈

Native Method Stack与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也即字节码）服务，而本地方法栈则是为虚拟机使用到的本地方法服务。
该区域规定的异常情况与虚拟机栈一样。

### 2.2.4 Java堆

对于Java应用来说。Java Heap是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，Java世界里几乎所有的对象实例都在这里分配内存。

Java堆是垃圾收集管理的内存区域，因此一些资料中它也被称为GC堆。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”、“老年代”、“永久代”、“Eden空间”等名词。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。若Java队中没有内存完成实例分配，且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemory异常。

### 2.2.5 方法区

Method Area与Java堆一样，是线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。垃圾收集行为在这个区域相对而言较少出现。该区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

根据《Java虚拟机规范》的规定，方法区无法满足新的内存分配需求时，将抛出OutOfMemory异常。

### 2.2.6 运行时常量池

Runtime Constant Pool是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容加载类加载后存放到方法区的运行时常量池中。

当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

### 2.2.7 直接内存

Direct Memory并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。这部分区域也可能会出现OOM异常。

JDK 1.4中加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储再Java堆里面的DirectByteBuffer对象作为这块内存的引用操作。在某些场景中能显著提升性能，因为避免了在Java堆与Native堆中来回复制数据。动态拓展时可能会出现OOM异常。

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

**对象创建的过程**：

1. Java虚拟机遇到一条字节码 `new` 指令时，首先检查指令的参数是否能在常量池中定位到一个类的符号引用，且检查该符号引用代表的类是否已被加载、解析和初始化过。若没有，那么先执行相应的类加载过程。
2. 类加载检查通过后，接着虚拟机将为新生对象分配内存。对象所需内存在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。
3. 内存分配完成后，虚拟机必须将分配到的内存空间都初始化为零值。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。
4. 接着，Java虚拟机还要对对象进行必要的设置，如该对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用 `Object::hashCode()` 方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。
5. 上述工作完成表示虚拟机的工作结束了，但Java程序需要根据构造函数，即Class文件中的 `<init>()` 方法将对象构造出来。

### 2.3.2 对象的内存布局

在Hotspot虚拟机中，对象在堆内存中的存储布局可划分为对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）三个部分。

1. **对象头**——Hotspot虚拟机的对象头部分包含两类信息。第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别位32比特和64比特，官方称它为“Mark Word”。第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并非所有的虚拟机实现都必须要经过对象本身。此外，若对象是一个Java数组，那么对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但若数组长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

2. **实例数据**——对象真正存储的有效信息，即各字段内容。

3. **对齐填充**——并非必然存在，也没有特别的含义。

### 2.3.3 对象的访问定位

《Java虚拟机规范》里面只规定了reference类型是一个指向对象的引用，对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：

- **句柄访问**。Java堆中可能会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自具体的地址信息。

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.2.png)

- **直接指针访问**。Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址。

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.2.3.png)

句柄访问的优势是reference中存储的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

直接指针访问的好处是速度更快，它节省了一次指针定位的时间开销。HotSpot使用了第二种方式进行对象访问。

## 2.4 实战：OutOfMemoryError异常

### 2.4.1 Java堆溢出

Java堆用于存储对象实例，只要不断地创建对象，且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

[这里](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/HeapOOM.java)的代码限制Java堆的大小为20MB，不可扩展（将堆的最小值 `-Xms` 参数与最大值 `-Xmx` 参数设置为一样即可避免堆自动扩展），参数 `-XX:+HeapDumpOnOutOfMemoryError` 可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便进行事后分析。

若是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与那些GC Roots相关联，才导致垃圾收集器无法回收它们。

若非内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数设置，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行时的内存消耗。

### 2.4.2 虚拟机栈和本地方法栈溢出

由于HotSpot虚拟机并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，`-Xoss` 参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由 `-Xss` 参数来设定。

《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展。除非在创建线程申请内存时就因无法获得足够内存而出现 `OutOfMemoryError` 异常，否则在线程运行时是不会因扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致 `StackOverflowError` 异常。

下面将实验范围限制在单线程内操作，尝试下面两个行为是否能让HotSpot虚拟机产生 `OutOfMemoryError` 异常：

- 使用 `-Xss` 参数减少栈内存容量。点击[这里](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/JavaVMStackSOF.java)查看代码。

- 定义大量的本地变量，增大此方法帧中本地变量表的长度。点击[这里](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/JavaVMStackSOF2.java)查看代码。

在HotSpot虚拟机下，两个实验都抛出 `StackOverflowError` 异常。可是如果在允许动态扩展栈容量大小的虚拟机上，相同代码会导致不一样的情况。

### 2.4.3 方法区和运行时常量池溢出

**运行时常量池**

HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代。

在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 限制永久代的大小，即可间接限制其中容量池的容量，具体实现如[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/RuntimeConstantPoolOOM.java)的代码所示。

在JDK 6中运行上述代码会抛出 `OutOfMemoryError` 异常且紧跟着的提示信息是“PermGen space”，说明运行时常量池的确是属于方法区（即JDK 6的HotSpot虚拟机中的永久代）的一部分。

而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使用 `-XX:MaxPermSize` 参数或者在JDK 8及以上版本使用 `-XX:MaxMetaspaceSize` 参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将会一直进行下去，永不停歇。这是因为自JDK 7起，原本存放在永久代的字符串常量被移至Java堆中。因此在JDK 7及以上版本，限制方法区的容量对改测试用例来说毫无意义。这时候使用 `-Xmx` 参数限制最大堆到6MB就能够抛出 `OutOfMemoryError` 异常。

**方法区**

对于方法区溢出的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出为止。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。

[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/JavaMethodAreaOOM.java) 的代码借助了CGLib直接操作字节码运行时生成了大量的动态类。

方法区溢出也是一种常见的内存溢出异常，一个类若要被垃圾收集器回收，要达成的条件是比较苛刻的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。

在JDK 8以后，永久代便被元空间代替。默认设置下，前述那些正常的动态创建新类型的测试用例已经很难再使虚拟机产生方法区的溢出异常了。但HotSpot还是提供了一些元空间相关的JVM参数：

- `-XX: MaxMetaspaceSize`：设置元空间最大值，默认是 `-1`，即不限制。
- `-XX: MetaspaceSize`：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：若释放了大量的空间，就适当降低该值；若释放了很少的空间，那么在不超过 `-XX: MaxMetaspaceSize` 的情况下，适当提高该值。
- `-XX: MinMetaspaceFreeRatio`：在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。

### 2.4.4 本机直接内存溢出

Direct Memory的容量大小可通过 `-XX:MaxDirectMemorySize` 参数来指定，若不去指定，则默认与Java堆最大值一致。

[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter2/DirectMemoryOOM.java) 的代码越过了 `DirectByteBuffer` 类通过反射获取 `Unsafe` 实例进行内存分配，因为虽然使用 `DirectByteBuffer` 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配就会在代码里手动排除溢出异常，真正申请分配内存的方法是 `Unsafe:: allocateMemory()`。

由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，若发现内存溢出之后产生的Dump文件很小，而程序又直接或间接地适用了DirectMemory，那就可以考虑重点检查一下直接内存方面的原因了。

# 3. 垃圾收集器与内存分配策略

## 3.1 概述

垃圾收集需要完成的三件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

程序计数器、虚拟机栈、本地方法栈的内存分配和回收都具备确定性。当方法结束或线程结束时，内存就跟着被回收了。

Java堆和方法区的内存分配和回收则有着不确定性，这些部分的内存分配和回收是动态的。垃圾收集器所关注的正式这部分内存该如何管理。

## 3.2 对象已死？

### 3.2.1 引用计数算法

在对象中添加一个引用计数器，每有一处引用它时，计数器值加一；每有引用失效时，计数器值减一。任何时刻计数器为零的对象就是不可能再被使用的。

**Reference Counting算法**原理简单，判定效率也高，多数情况下是一个不错的算法。但主流的java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须配合大量额外的工作才能保证正确工作，如单纯的引用计数就很难解决对象之间相互循环引用的问题。

### 3.2.2 可达性分析算法

当前主流的商用程序语言（Java、C#、Lisp
）的内存管理子系统，都是通过可达性分析（Reachablility Analysis）算法来判断对象是否存活的。基本思路是通过一系列称为“GC Roots”的跟对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中所走过的路径被称为“引用链”，若某对象到GC Roots间没有任何引用链相连则证明此对象是不可能再被使用的。

在Java技术体系里，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，如线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

- 在方法区中类静态属性引用的对象，如Java类的引用类型静态变量。

- 在方法区中常量引用的对象，如字符串常量池里的引用。

- 在本地方法栈中JNI（即Native方法）引用的对象。

- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如NullPointerException、OutOfMemoryError）等，还有系统类加载器。

- 所有被同步锁持有的对象。

- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 3.2.3 再谈引用

在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为*Strongly Reference*、*Soft Reference*、*Weak Reference*、*Phantom Reference* 4种，这4种引用强度依次逐渐减弱。

- **强引用**。最传统的“引用”的定义，是指代码中普遍存在的引用赋值，即类似Object obj = new Object()这种引用关系。无论何种情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- **软引用**。用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，若这次回收还没有足够的内存，才会抛出内存溢出异常。
- **弱引用**。用来描述哪些非必须对象，但其强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
- **虚引用**。也称为”幽灵引用“或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

### 3.2.4 生存还是死亡？

即使在可达性分析算法中判定为不可达的对象，要真正宣告一个对象死亡，至少要经历两次标记过程：若对象被判定为不可达对象后，它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize()` 方法。假如对象没有覆盖 `finalize()` 方法，或者 `finalize()` 方法已经被虚拟机调用过,那么虚拟机将这两种情况都视为“没有必要执行”。

若对象被判定为有必要执行 `finalize()` 方法，该对象将会被放置在一个名为*F-Queue*的队列之中，并在稍后由一条虚拟机自动建立的、低调度优先级的*Finalizer*线程去执行 `finalize()` 方法。稍后收集器对*F-Queue*中的对象进行第二次标记，若对象在 `finalize()` 方法中重新被引用，那么第二次标记时它将会被移出“即时回收”的集合；否则对象真的要被回收了。

[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter3/FinalizeEscapeGC.java) 的代码演示了一个对象的自我拯救。

### 3.2.5 回收方法区

方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往是很低的。

方法区的垃圾收集主要回收两部分内容：

- 废弃的常量。
- 不再使用的类型。

回收常量与回收Java堆中的对象非常类似。

判定一个类型是否属于“不再使用的类”的条件比较苛刻，需要同时满足：

- 该类所有实例都已经被回收，亦即Java堆中不存在该类及其派生子类的实例。
- 加载该类的类加载器已经被回收，

<TO BE CONTINUED>

## 3.3 垃圾收集算法

从如何判定对象消亡的角度出发，垃圾收集算法可以被划分为“引用计数式垃圾收集”和“跟踪式垃圾收集”两大类。本节介绍的算法均属于跟踪式垃圾收集的范畴。

### 3.3.1 分代收集理论

分代收集理论建立在两个分代假说之上：

- **弱分代假说**：绝大多数对象都是朝生夕灭的。
- **强分代假说**：熬过越多次垃圾收集过程的对象就越难消亡。

这两个假说共同奠定了主流垃圾收集器的一致设计原则：收集器应该将Java堆划分为不同的区域，然后将回收对象依据其年龄（熬过垃圾收集过程的次数）分配到不同的区域之中存储。若一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收只关注少量存活而不是去标记大量将要被回收的对象，就能以较低代价回收大量的空间；若剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域。兼顾垃圾收集的时间开销和内存空间的有效利用。

在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收部分区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对对象存亡特征安排不同的垃圾收集算法。

把分代收集理论具体放到现在的商用虚拟机里，设计者一般至少会把Java堆划分为为新生代和老年代两个区域。

分代收集并非只是简单地划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会跨代引用。

为了解决这个问题，就需要堆分代收集理论添加第三条经验法则：

- **跨代引用假说**：跨代引用相对于同代引用来说仅占极少数。

依据该假说，我们不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构将老年代划分成若干小块，标识出老年代的那一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

### 3.3.2 标记-清除算法

**原理**：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

**缺点**：

- 执行效率不稳定，如果Java堆中包含大量对象，且其中大部分是需要被回收的，这时必须进行大量的标记和清除动作。
- 内存空间碎片化问题。

### 3.3.3 标记-复制算法

**原理**：

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把一使用过的内存空间一次清理掉。

**优点**：

- 多数对象可回收时，算法需要复制的就是占少数的存活对象。
- 解决了内存空间碎片的问题。

**缺点**：

- 多数对象存活时，将产生大量的内存间复制的开销。

### 3.3.4 标记-整理算法

**原理**：

针对老年代对象的存亡特征，标记-整理算法被提出，其中的标记过程仍然与“标记-清除”算法一样，而后让所有存活的对象对象内存空间一段移动，然后直接清理掉边界以外的内存。

**优点**：

- 避免内存空间碎片。
- 相较于“标记-复制”算法在对象存活率较高时提升了效率，且不会浪费额外的内存空间。

**缺点**：

- 内存回收比不移动对象的算法更复杂。
- 对象移动操作必须全程暂停应用程序才能进行。

## 3.4 HotSpot的算法细节实现

<待读>

## 3.5 经典垃圾收集器



# 7. 虚拟机加载机制

代码编译的结果是从本地机器码转变为字节码。

## 7.1 概述

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载过程。

## 7.2 类加载时的机制

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载七个阶段，其中验证、准备、解析三个阶段统称为连接（Linking）。

# 10 前端编译与优化

## 10.1 概述

- 前端编译：把 `*.java` 文件转变成 `*.class` 文件的过程；
- 即时编译（Just in Time Compilation）：运行期把字节码转变为本地机器码的过程；
- 静态的提前编译（Ahead of Time Compilation）：直接把程序编译成与目标机器指令集相关的二进制代码的过程。

## 10.2 `Javac` 编译器

`Javac`编译器不像HotSpot虚拟机那样使用C++语言实现，它本身就是由Java语言编写。

### 10.2.1 Javac的源码与调试

《Java虚拟机规范》对如何把Java源码编译为Class文件描述得相当宽松。使得Class文件的编译过程在某种程度上是与具体的JDK或编译器实现相关的。

`Javac` 的编译过程如下所示：

1. 准备过程：初始化插入式注解器
2. 解析与填充符号表过程，包括：
    - 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。
    - 填充符号表。产生符号地址和符号信息。
3. 插入式注解处理器的注解处理过程：插入时注解处理器的执行阶段。
4. 分析与字节码生成过程，包括：
    - 标注检查。对语法的静态信息进行检查。
    - 数据流及控制流分析。对程序动态运行过程进行检查。
    - 解语法糖。将简化代码变法的语法糖还原为原有的格式。
    - 字节码生成。将前述各步骤所产生的信息转换为字节码。

执行插入式注解时又可能会产生新的符号，若有新符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号。处理过程的交互顺序如图：

```
[类文件]--->[解析与填充符号表]--->[注解处理]--->[分析与字节码生成]--->[字节码]
         ^                                   |
         |                                   |
         +-----------------------------------+
```

上述处理到OpenJDK中的 `JavaCompiler` 类的源码中如下：

```
public void compile(List<JavaFileObject> sourceFileObjects,
                        List<String> classnames,
                        Iterable<? extends Processor> processors) {
    ...
    initProcessAnnotations(processors); //准备过程：初始化插入式注解处理器
    
    delegateCompiler =
        processAnnotations( //过程2：执行注解处理
            enterTrees(stopIfError(CompileState.PARSE, //过程1.2： 输入到符号表
                parseFiles(sourceFileObjects))), //过程1.1：词法分析、语法分析
            classnames);
    
    delegateCompiler.compile2();  //过程3：分析及字节码生成
    ...
}

private void compile2() {
    ...
    case BY_TODO:
        while (!todo.isEmpty())
            generate(  //过程3.4：生成字节码
                desugar(  //过程3.3：解语法糖
                    flow(  //过程3.2：数据流分析
                        attribute(todo.remove()))));  //过程3.1：标注
        break;
    ...
}
```

<To be continued>

# 11 后端编译

## 11.1 概述

若把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话，那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。

后端编译包括提前编译和即时编译。

## 11.2 即时编译器

目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某方法或代码块的运行特别频繁，就会把这些代码认定为热点代码（Hot Spot Code），为提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成本地机器码，运行时完成这个任务的后端编译器称作即时编译器。

### 11.2.1 解释器与编译器

尽管并不是所有的Java虚拟机都采用解释器与编译器并存的运行架构，但目前主流的商用Java虚拟机，譬如HotSpot、OpenJ9等，内部都同时包含解释器与编译器。

解释器和编译器各有长处：

- 程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译时间，立即运行。
- 程序启动后，随着时间的推移，编译器主键发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。
- 解释器可节约内存，编译器可以提高执行效率。
- 解释器可以作为编译器激进优化时后背的“逃生门”。

![image](https://github.com/janwee-sha/reading-notes/blob/main/Java/images/Jvm.in.Depth.Figure.11.1.png)

HotSpot虚拟机中内置了两个（或三个）即时编译器，其中有两个编译器存在已久，分别被称为“客户端编译器”（ Client Compiler）和“服务端编译器”（Server Compiler），或者简称为C1编译器和C2编译器，第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。

JVM参数：

- `-client`：客户端模式
- `-server`：服务端模式
- `-Xint`：解释模式
- `-Xcomp`：编译模式

虚拟机执行模式：

```
$ java -version
java version "1.8.0_92"
Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)

$ java -Xint -version
java version "1.8.0_92"
Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, interpreted mode)

$ java -Xcomp -version
java version "1.8.0_92"
Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, compiled mode)
```

由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，花费的时间便会越长；且想要编译出优化成都更高的代码，解释器可能还要提编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。

为了在程序启动响应速度与运行效率间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能，包括：

- 第0层。程序纯解释执行，且解释器不开启性能监控功能。
- 第1层。使用客户端编译器将字节码编译成本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。
- 第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。
- 第3层。仍然使用客户端编译器执行，开启全部性能监控，除第上述统计信息外，还会收集分支跳转、虚方法调用版本等。
- 第4层。使用服务都安编译器将字节码编译为本地代码，相比客户端编译器，服务都安编译器会启用更多的编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。

实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译。

### 11.2.2 编译对象与触发条件

热点代码主要有两类：

- 被多次调用的方法。
- 被多次执行的循环体。

<To be continued>

## 11.3 提前编译器

如IBM High Performance Compiler for Java、GCJ等提前编译器都曾被广泛使用。

但是提前编译很快又在Java世界里沉寂了下来，因为当时Java的一个核心优势是平台中立。这种2013年，使用提前编译的ART（Android Runtime）被发布。

### 11.3.1 提前编译的优劣得失

实现提前编译的两种思路：

1. **静态提前编译**——在程序运行前把程序代码编译成机器码的静态翻译工作（类似传统C、C++编译器）；
    
    这种方式不存在即时编译占用程序运行时间和运算资源的劣势。

2. **动态提前编译**——把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接把它加载进来使用。
    
    这种方式的本质上时给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能达到最高性能的问题。这种提前编译被称为动态提前编译（Dynamic AOT）或即时编译缓存（JIT Caching）。

目前的Java技术体系里，动态提前编译已经完全被主流的商用JDK支持。

<To be continued>

# 12 Java内存模型与线程

## 12.1 概述

**为什么要多任务处理**？

- 平衡计算机的运算速度与它的存储和通信子系统的速度差异，充分利用计算机处理器的能力。
- 服务端通常要同时对多个客户端提供服务。

## 12.2 硬件的效率与一致性

由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存速度间的矛盾，但它引入了一个新的问题：**缓存一致性**（Cache Coherence）。

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。

处理增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码的顺序一致，因此若存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。

## 12.3 Java内存模型

### 12.3.1 主内存与工作内存

Java内存模型规定了所有变量都存储在主内存中（类比物理硬件的主内存）。每条线程还有自己的工作内存（类比处理器高速缓存），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。

> Note: 据《Java虚拟机规范》约定，`volatile` 变量依然有工作内存的拷贝，但由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写一般，因此这里的描述对于 `volatile` 也不存在例外。

### 12.3.2 内存间交互操作

Java内存模型针对主内存与工作内存的交互定义了以下8种原子的操作：

- `lock`：作用于主内存的变量，把一个变量标识为一条线程独占的状态。
- `unlock`：作用于主内存的变量，把一个处于**锁定**状态的变量释放出来。
- `read`：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存种，以便随后的 `load` 操作使用。
- `load`：作用于工作内存的变量，把 `read` 操作从主内存种得到的变量值放入工作内存的内存副本中。
- `use`：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行此操作。
- `assign`：作用于工作内存的变量，把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行此操作。
- `store`：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 `write` 操作使用。
- `write`：作用于主内存的变量，把 `store` 操作从工作内存中得到的变量的值放入主内存的变量。

### 12.3.3 对于 `volatile` 型变量的特殊规则

`volatile` 变量的两个特性：

- 保证此变量对所有线程的可见性。
- 禁止指令重排序优化。

对于 `volatile` 变量“可见性”的特性，`volatile` 变量对所有线程是立即可见的， `volatile` 变量在各个线程的工作内存中是不存在一致性问题的，但Java里面的运算操作并非原子操作，这导致 `volatile` 变量的运算在并发下一样是不安全的。

[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter12/VolatileTest.java) 的代码的测试结果可验证上述结论，这段代码的问题出在 `race++;` 之中，`volatile` 关键字保证了 `race` 的值在读取时是正确的，但是在执行赋值操作的时候，其他线程可能已经把 `race` 的值改变了，而操作栈顶的值就变成了过期的数据。

由于 `volatile` 变量只能保证可见性，在不符合以下两条规则的运算场景中，仍需要通过加锁来保证原子性：

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
- 变量不需要与其他状态变量共同参与不变约束。

对于 `volatile` 变量“禁止指令重排序优化”的特性，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与代码中执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“线程内表现为串行”的语义。

[此处](https://github.com/janwee-sha/reading-notes/blob/main/Java/codes/JVM.in.Depth/chapter12/DCLSingleton.java)的代码所示是一段标准的双锁检测单例代码。代码中使用 `volatile` 关键字修饰 `instance` 的目的在于禁止指令重排序。由于 `instance = new DCLSingleton();` 的赋值操作并非原子操作，而 `volatie` 关键字可以防止赋值操作的各个子操作按顺序执行。

### 12.3.4 针对 `long` 和 `double` 型变量的特殊规则

Java内存模型要求 `lock`、`unlock`、`read`、`load`、`assign`、`use`、`store`、`write`这8种操作都具有原子性，但对于64位的数据类型（`long` 和 `double`），在模型中特别定义了一条宽松的规定：允许虚拟机将没有被 `volatile` 修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据的 `read`、`load`、`write`、`store`这四个操作的原子性。

若有多个线程共享一个并未声明为 `volatile` 的 `long` 和 `double` 类型的变量，且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了“半个变量”的数值。

不过这种“半个变量”的情况随着主流Java虚拟机的迭代而非常罕见了。因此实际开发一般不需要因为这个原因可以把用到的 `long` 和 `double` 变量声明为 `volatile`。