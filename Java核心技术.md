# 卷一

## 14 并发

多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。

多线程与多进程的本质区别在于每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在有些操作系统中，与进程比较，线程更“轻量级”，创建、撤销线程的开销比进程要小得多。

### 14.1 什么是线程

直接调用Thread类或Runnable对象的run方法，只会执行同一个线程中的任务，而不会启动新线程。调用Thread.start方法将创建一个执行run方法的新线程。

### 14.2 中断线程

Java早期版本中的Thread.stop方法可以用来终止线程，但该方法现在已经被弃用了。

当对一个线程调用interrupt方法时，线程的中断状态将被置位。每个线程都应该不时地检查这个标志，以判断线程是否被中断。

使用isInterrupted方法判断一个线程是否被置位。

被阻塞的线程就无法检测中断状态。当在一个被阻塞的线程上调用interrupt方法时，阻塞调用将会被Interrupted Exception异常中断。

没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。线程简单地将中断作为一个终止请求时run方法具有如下形式：

```
Runnable r = () -> {
    try {
        ...
        while(!Thread.currentThread().isInterrupted() && more work to do) {
            do more work
        } catch (InterruptedException e) {
            //thread was interrupted during sleep or wait
        } finally {
            clean up if nessary
        }
        //exiting the run method terminates the thread
    }
};
```

如果中断状态被置位时调用sleep方法不会休眠线程，相反，它将清楚这一状态并抛出InterruptedException。

interrupted是一个静态方法，它检测当前的线程是否被中断并清除该线程的中断状态；isInterrupted是一个实例方法，可用来检测线程是否被中断且不会改变中断状态。

### 14.3 线程状态

线程可以有以下6种状态：

- New（新创建）
- Runnable（可运行）
- Blocked（阻塞）
- Waiting（等待）
- Timed waiting（计时等待）
- Terminated（被终止）

#### 14.3.1 新创建线程

当用new操作符创建一个新线程时，该线程还没有开始运行，此时线程处于新创建状态。

#### 14.3.2 可运行线程

一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在云南行也可能没有运行，这取决于操作系统给线程提供运行的时间。

一旦一个线程开始运行，它不必始终保持运行。抢占式调度系统给每一个可运行线程一个时间片来执行任务。

现在所有的桌面以及服务器操作系统都是用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用yield方法，或者被阻塞或等待时，线程才失去控制权。

#### 14.3.3 被阻塞线程和等待线程

当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何且消耗最少的资源。

- 当一个线程试图获取一个内部的对象锁（而不是java.util.concurrent库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将编程非阻塞状态。
- 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。
- 有几个方法有一个超时参数。调用它们导致线程进入计时等待（timed waiting）状态。这一状态将一直保持到超时期满或者接收适当的通知。

#### 14.3.4 被终止的线程

线程被终止有两个原因：

- 因为run方法正常退出而死亡。
- 因为一个没有捕获的异常终止了run方法而意外死亡。

void join()
等待终止指定的线程。

void join(long millis)
等待指定的线程死亡或者经过指定的毫秒数。

Thread.join方法和wait方法、notify方法一起，用于实现Java线程间的同步机制。

#### 14.4.2 守护线程

可以通过调用`Thread.setDaemon(true)`将线程转换为守护线程。当 JVM 中不存在任何一个正在运行的非守护线程时，则 JVM 进程即会退出。守护线程的唯一用途是为其他线程提供服务。

#### 14.4.3 未捕获异常处理器

（待读）

### 14.5 同步

通常两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改对象状态的方法，此时根据线程访问数据的次序，可能会产生讹误的对象。这样一种情况通常称为竞争条件。

####  14.5.3 锁对象

有两种机制防止代码块受并发访问的干扰。Java语言提供一个synchronized关键字达到这一目的，并且Java SE 5.0引入了ReentrantLock类。synchronized关键字自动提供了一个锁以及相关的“条件”，对于大多数需要显式锁的情况，这是很便利的。

锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（hold count）来跟踪对lock方法的嵌套调用。

ReentrantLock()
构造一个可以用来被保护临界区的可重入锁。

ReentrantLock(boolean fair)
构造一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程，但是会大大降低性能。

#### 14.5.4 条件对象

通常，线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理哪些已经获得了一个锁但是却不能做有用工作的线程。

等待获得锁的线程和调用await方法的线程存在本质上的不同。

一旦一个线程调用await方法，它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的signalAll方法时为止。

通常，对await的调用应该再如下形式的循环体中：

```
while(!(ok to proceed))
    condition.await();
```

另一个方法signal，则是随机接触等待集中某个线程的阻塞状态。这比接触所有线程的阻塞更加有效，但也存在死锁的危险。

#### 14.5.5 synchronized关键字

锁和条件的关键之处：

- 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被保护代码段的线程。
- 锁可以拥有一个或多个相关的条件对象。
- 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。

Lock和Condition接口为程序设计人员提供了高度的锁定控制。然而，大多数情况并不需要那样的控制，并且可以使用一种嵌入到Java语言内部的机制。从1.0版开始，Java中的每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象锁将保护整个方法。也就是说，线程要调用该方法就必须获得内部的对象锁。

内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态。

将静态方法声明为synchronized也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。

内部锁和条件存在一些局限。包括：

- 不能中断一个正在试图获得锁的线程。
- 试图获得锁时不能设定超时。
- 每个锁仅有单一的条件，可能是不够的。

使用一个对象的锁来实现额外的原子操作，实际上称为客户端锁定（client-side locking）。

**截获锁**

对于拥有同步方法的类，如Vector，我们可以截获它的锁：

```
public void transfer(Vector<Double> accounts,int from,int to,int amount) {
    synchronized (accounts) {
        accounts.set(from, accounts.get(from) - amount);
        accounts.set(to, accounts.get(to) + amount);
    }
}
```

这个方法可以工作，但是它完全依赖于类对自己的所有可修改方法都使用内部锁。

因此，客户端锁定是非常脆弱的，通常不推荐使用。

#### 14.5.7 监视器概念

锁和条件是线程同步的强大工具，但严格地说并不是面向对象的。研究人员努力寻找一种方法，可以在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性。最成功的解决方案之一是监视器（monitor）。

用Java的术语，监视器具有如下的特性：

- 监视器只包含私有域的类。
- 每个监视器的对象有一个相关的锁。
- 使用该锁对所有方法进行加锁。即，若客户端调用obj.method()，那么obj对象的锁是在方法调用开始时自动获得，且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域。
- 该锁可以有任意多个相关条件。

监视器的早期版本只有单一的条件，使用一种很优雅的句法。可以简单地调用await accounts[from]>=balance而不是用任何显式的条件变量。然而，研究表明盲目地重新测试条件是低效的。显式的条件变量解决了这一问题。每一个条件变量管理一个独立的线程集。

Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现得就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。

Java对象有3个方面不同于监视器，从而使得线程的安全性下降：

- 域不要求必须是private。
- 方法不要求必须是synchronized。
- 内部锁对客户是可用的。

#### 14.5.15 为什么弃用stop和suspend方法

stop和suspend都有一些共同点：都试图控制一个给定线程的行为。

stop方法终止所有未结束的方法，包括run方法。当线程被终止，立即释放被它所著的所有对象的锁。这会导致对象处于不一致的状态。

当线程要终止另一个线程时，无法知道什么时候调用stop方法是安全的，什么时候导致对象被破坏。

如果suspend挂起一个持有一个锁的线程，那么，该锁在恢复之前是不可用的。如果调用suspend方法的线程试图获取同一个锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待恢复锁。