# 1 简介

## 1.1 ZooKeeper的使命

ZooKeeper可以在分布式系统中协作多个任务。一个协作任务是指一个包含多个进程的任务。这个任务可以是为了协作或者是为了管理竞争。协作意味着多个进程需要一同处理某些事情，一些进程采取某些行动使得其他进程可以继续工作。竞争指的是两个进程不能同时处理工作的情况，一个进程必须等待另一个进程。

Zookeeper的使用实例：

**Apache HBase**

HBase是一个通常与Hadoop一起使用的数据存储仓库。在HBase中，ZooKeeper用于选举一个集群内的主节点，以便跟踪可用的服务器，并保存集群的元数据。

**Apache Kafka**

一个基于发布-订阅模型的消息系统。ZooKeeper用于检测崩溃，实现主题的发现，并保持主题的生产和消费状态。

**Apache Solr**

一个企业级的搜索平台。使用ZooKeeper存储集群的元数据，并协作更新这些元数据。

**Facebook Messages**

将ZooKeeper作为控制器，实现数据分片、故障恢复和服务发现等功能。

ZooKeeper的客户端API功能强大，其中包括：

- 保障强一致性、有序性和持久性。
- 实现通用的同步原语的能力。
- 在实际分布式系统中，并发往往导致不正确的行为。ZooKeeper提供了一种简单的并发机制。

### 1.1.2 ZooKeeper不适用的场景

ZooKeeper不适合用作海量数据存储。

### 1.1.4 通过ZooKeeper构建分布式系统

使用一个独立的协调组件有几个重要的好处：

- 独立地设计和实现该组件，这样独立的组件可以跨多个应用共享。
- 系统架构师可以简化协作方面的工作，这些并不是琐碎的i下凹式。
- 系统可以独立地运行和协作这些组件，也简化了生产环境中解决实际问题的任务。

分布式系统的进程通信有两种选择：直接通过网络进行信息交换，或读写某些共享存储。ZooKeeper使用共享存储模型来实现应用间的协作和同步原语。对于共享存储本身，又要在进程和存储间进行网络通信。

在真实的系统中，我们需要特别注意以下问题：

- 消息延迟——消息传输可能会发生任意延迟。
- 处理器性能——操作系统的调度和超载也可能导致消息处理的任意延迟。
- 时钟偏移——处理器时钟并不可靠，它们之间也会发生任意的偏移。依赖处理器始终也许会导致错误的决策。

## 1.2 示例：主-从应用

在主-从架构中，主节点进程赋值跟踪从节点状态和任务的有效性，并分配任务到从节点。

要实现主-从模式，我们必须解决以下三个关键问题：

- 主节点崩溃
  
  如果主节点发送错误并使小，系统将无法分配新的任务或重新分配已失败的任务。

- 从节点崩溃

  如果从节点崩溃，已分配的任务将无法完成。

- 通信故障

  如果主节点和从节点之间无法进行信息交换，从节点将无法得知新任务分配给它。
 
### 1.2.1 主节点失效

主节点失效时，我们需要有一个备份主节点（backup master）。当主要主节点（primary master）崩溃时，备份从节点接管主要主节点的角色，进行故障转移。新的主要主节点需要能够恢复到旧的主要主节点崩溃时的状态。对于主节点状态的可恢复性，我们不能依靠从已经崩溃的主节点来获取这些信息，而需要从其他地方获取，也就是通过ZooKeeper来获取。

状态恢复并不是唯一的重要问题。例如主机点有效，备份主节点却认为主节点已经崩溃。从而接管主节点的角色，成为第二个从节点。更糟的是从系欸但因为无法与主要主节点通信，而与第二个主节点建立主-从关系。这种场景一般称为脑裂。

### 1.2.2 从节点失效

如果从节点崩溃了，所有已派发给这个从节点且尚未完成的任务需要重新派发。其中首要需求是让主节点具有检测从节点崩溃的能力。从节点崩溃时也许执行了部分任务，也许全部执行完但没有报告结果。如果整个运算过程产生其他作用，我们还有必要执行某些恢复过程来清除之前的状态。

### 1.2.3 通信故障

如果一个从节点与主节点的网络连接断开，比如网络分区（network partition）导致，重新分配一个任务可能会导致两个从节点执行相同的任务。如果任务允许多次执行，我们不用验证第一个从几点是否完成了该任务；否则应用需要适应多个从节点执行相同任务的可能性。

通信故障导致的另一个重要问题时对锁等同步原语的影响。因为系统也可能网络分区，锁机制也会组织任务的继续执行。因此ZooKeeper也需要实现处理这些情况的机制。首先，客户端可以告诉ZooKeeper某些数据的状态是临时状态；其次，客户端需要定时发送是否存活的通知，如果一个客户端未能及时发送通知，所有从属于它的临时数据将被全部删除。通过这两个机制，可以预防客户端独立运行而发生的应用宕机。

### 1.2.4 任务总结

据前所述，可以得到主-从架构的需求：

- **主节点选举**

  使得主节点可以给从节点分配任务。

- **崩溃检测**

  主节点具有检测从节点崩溃或失去连接的能力。
  
- **组成员关系管理**

  主节点必须具有指导哪一个从节点可以执行任务的能力。
  
- **元数据管理**
   
  主节点和从节点必须具有通过某种可靠的方式来保持分配状态和执行状态的能力。

理想的方式是，上述任务都需要通过原语的方式暴露给应用，对开发者完全隐藏细节。ZooKeeper提供了实现这些原语的关键机制，因此，开发者可以通过这些实现一个最适合需求、更加关注应用逻辑的分布式应用。

## 1.3 分布式协作的难点

我们无法拥有一个理想的故障容错的、分布式的、真实环境存在的系统来处理可能发生的所有问题。但我们还是可以争取一个稍微不那么么宏伟的目标。

# 2 了解ZooKeeper

## 2.1 ZooKeeper基础

ZooKeeper数据结构示例：


```
[ ] /
|
|----[server id] /master
|
|----[ ] /workers
|     |
|     |----[foo.com:2181] /workers/worker-1
|
|----[ ] /tasks
|     |
|     |----[run cmd;] /tasks/task-1-2
|
|----[ ] /assign
        |
        |----[ ] /assign/work-1
              |
              |----[run cmd;] /assign/worker-1/task-1-1
```

./master表示主节点，对应的znode没有数据表示还没有选举出主节点。

./workers节点下每个znode子节点保存了系统中一个可用从节点信息。

./tasks节点下每个znode子节点保存了所有已经创建并等待从节点执行任务的信息。

./assign节点下的每个znode子节点保存了分配到某个从节点的一个任务信息。

### 2.1.1 API概述

znode傲寒数据时，数据存储为字节数组。字节数组的具体格式特定于每个应用的实现，ZooKeeper并不直接提供解析的支持。

ZooKeeper的API暴露了以下方法：

- **create/path data**

  创建一个名为/path的znode节点，并包含数据data。

- **delete/path**

  删除名为/path的znode。
- **exist/path**

  检查是否存在名为/path的节点。
  
- **setData/path data**

  设置名为/path的znode的数据为data。
  
- **getData/path data**

  返回名为/path节点的数据信息。
  
- **getChildren/path**

  返回所有/path节点的所有子节点列表。

ZooKeeper并不允许局部写入或读取znode节点的数据。

### 2.1.2 znode的不同类型

当新建znode时，还需要指定该节点的类型（mode），不同的类型决定了znode节点的行为方式。

**持久节点和临时节点**

持久（persistent）节点只能通过delete来删除。临时（ephemeral）节点在客户端崩溃或关闭了与ZooKeeper的连接时，这个节点就会被删除。

持久znode是一种非常有用的znode，可以通过持久类型的znide为应用保存一些数据，即使创建者不再属于应用系统时。如，主-从模式例子中，需要保存从节点的任务分配情况，即使主节点已经崩溃。

临时znode系欸但传达了应用某些方面的信息，仅当创建者的会话有效时这些信息必须有效保存。如，在主-从模式中，临时节点的存在与否可以传达节点是否崩溃的信息。

因为临时znode在其创建者的会话过期时被删除，所以（目前）不允许临时节点拥有子节点。

**有序节点**

一个znode还可以设置为有序（sequential）节点。有序节点被分配为一个单调递增的证书。当创建有序节点后，一个序号会被追加到路径之后。

综上，znode一共有4中类型：持久的（persistent）、临时的（ephemeral）、持久有序的（persistent_sequential）和临时有序的（ephemeral_sequential）。

### 2.1.3 监视与通知

ZooKeeper通常以远程服务的方式被访问，如果客户端每次访问znode都需要获得节点中的内容，这样的代价就非常大。为了替换客户端的轮循，ZooKeeper选择了基于通知（notification）的机制：

1. 客户端C2调用`getChildren /tasks`读取任务列表，其初始值为空，并调用`set watch`设置一个监控变更的监视点。
2. 当发生变化时ZooKeeper通知客户端。
3. 客户端C2调用`getChildren /tasks`读取任务列表。

### 2.1.4 版本

每一个znode都有一个版本号，它随着每次数据变化而自增。两个API操作可以有条件地执行：setData和delete。这两个调用以版本号作为传入参数，只有当传入参数的版本与服务器的版本一致时调用才会成功。

## 2.2 ZooKeeper架构

ZooKeeper服务器运行于两种模式下：独立模式（standalone）与仲裁模式（quorum）。独立模式有一个单独的服务器，ZooKeeper状态无法复制。仲裁模式具有一组服务器，它们之间可以进行状态的复制，并同时为客户端服务。

### 2.2.1 ZooKeeper仲裁

仲裁模式下，ZooKeeper复制集群中的所有服务器的数据树。