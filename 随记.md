# SQL HAVING子句

在SQL中增加HAVING子句的原因是，WHERE子句关键字无法与聚合函数一起使用，HAVING子句可以让我们筛选分组后的各组数据。

**SQL HAVING 语法**

```
SELECT col_name, aggregate_function(col_name)
FROM tbl_name
WHERE col_name operator value
GROUP BY col_name
HAVING aggregate_function(col_name) operator value;
```

# MySQL 字符串函数

- **ASCII(s)**，返回字符串s的第一个字符的ASCII码。
```
SELECT ASCII('Hello');
-- 72
```

- **CHAR_LENGTH(s)**、**CHARACTER_LENGTH(s)**、**LENGTH(s)**，返回字符串s的字符数。
```
SELECT CHAR_LENGTH('Hello');
-- 5
```

- **CONCAT(s1,s2...)**，合并字符串列表(s1,s2...)。
```
SELECT CONCAT('hello',' ','world');
-- hello world
```

- **CONCAT_WS(x,s1,s2...)**， 以x为分隔符合并字符串列表(s1,s2...)
```
SELECT CONCAT_WS(' ','hello','world');
-- hello world
```

- **FIELD(s,s1,s2...)**， 返回第一个字符串s在字符串列表(s1,s2...)中的位置。
```
SELECT FIELD('c','a','b','c','d');
-- 3
```

- **FIND_IN_SET(s1,s2)**， 返回字符串s2中与s1匹配的字符串的位置。
```
SELECT FIND_IN_SET('c','a,b,c,d,e');
-- 3
```

- **FORMAT(x,n)**，将数字x进行格式化，并保留到小数点后n位 。
```
SELECT FORMAT(PI()*10000,2);
-- 31,415.93
```

- **INSERT(s1,x,len,s2)**， 字符串s2替换s1的x位置开始长度为len的字符串。

- **LOCATE(s1,s2)**，从字符串s2中获取s1的开始位置。
```
SELECT LOCATE('christmas','merry christmas');
-- 7
```

- **LCASE(s)**、**LOWER(s)**，小写转换字符串s中的所有字母。 

- **LEFT(s,n)**，返回字符串s的前n个字符。

- **LPAD(s1,len,s2)**，在字符串s1的开始处填充字符串s2，使字符串长度达到len。
```
SELECT LPAD(' world',11,'hello');
-- hello world
```

- **LTRIM(s)**，去掉字符串s开始处的空格。 

-**MID(s,start,len)**、**SUBSTR(s,start,len)**、**SUBSTRING(s,start,len)**，截取子字符串。





# MySQL 日期函数

- **ADDDATE(d,INTERVAL expr type)**、**DATE_ADD(d,INTERVAL expr type)**，计算时间表达式d加上区间表达式后的时间。


```
SELECT ADDDATE('2022-02-22 22:22:22',INTERVAL 1 SECOND);
-- 2022-02-22 22:22:23
```

- **ADDTIME(t,n)**，计算时间表达式t加上时间表达式n后的时间。


```
SELECT ADDTIME('2022-02-22 22:22:22',1);
-- 2022-02-22 22:22:23
```

- **CURDATE()**、**CURRENT_DATE()**，返回当前日期。

- **CURRENT_TIME()**、**CURTIME()**，返回当前时间。

- **CURRENT_TIMESTAMP()**，返回当前日期和时间。

- **DATE()**，从日期或日期时间表达式中提起日期值。

- **DATEDIFF(d1，d2)**，计算日期d1->d2之间相隔的天数。
```
SELECT DATEDIFF('2022-1-8 22:15:00','2022-1-9');
-- -1
```

# SQL BETWEEN操作符

BETWEEN操作符用于选取介于两个值之间的数据范围内的值。

BETWEEN语法：
```
...col_name BETWEEN value1 AND value2;
```

# MySQL OLAP函数

开窗函数（OLAP函数）：为将要被操作的行的集合定义一个窗口，它对一组值进行操作，不需要使用GROUP BY子句对数据进行分组，能够在同一行中同时返回基础行的列和聚合列。

**OLAP的语法结构：**
```
OVER ([PARTITION BY <列清单>] ORDER BY <排序用列清单>)
```

**开窗函数一般分为两类：**

- 能够作为开窗函数的聚合函数，如SUM、AVG、COUNT、MIN。
- 专用开窗函数，如RANK、DENSE、ROW、ROW_NUMBER。

*聚合开窗函数只能使用PARTITION BY子句，ORDER BY不能与聚合开窗函数一同使用。*

# SQL FULL OUTER JOIN 关键字

MySQL不支持FULL OUTER JOIN。

# SQL SELECT INTO 语句

SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。

MySQL数据库不支持SELECT...INTO语句但支持INSERT INTO...SELECT。

# SQL INSERT INTO SELECT语句

INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。

# SQL约束

- **NOT NULL**
- **UNIQUE**

    创建表时创建UNIQUE约束：
    ```
    CRAETE TABLE tbl_name(
        col_name type UNIQUE,
        ...);
    ```
    ```
    CRAETE TABLE tbl_name(
        ...,
        UNIQUE(col_name));
    ```
    修改表时在某列上创建UNIQUE约束；
    ```
    ALTER TABLE tbl_name
        ADD UNIQUE (col_name);
    ```
    修改表时定义多个列的UNIQUE约束：
    ```
    ALTER TABLE tbl_name
        ADD CONSTRAINT constraint_name UNIQUE (col_name1,col_name2);
    ```
    撤销UNIQUE约束：
    **MySQL:**
    ```
    ALTER TABLE tbl_name
        DROP INDEX col_name;
    ```
    **SQL Server/Oracle/MS Access:**
    ```
    ALTER TABLE tbl_name
        DROP CONSTRAINT constraint_name;
    ```
    

- **PRIMARY KEY**
    PRIMARY KEY约束唯一标识数据库表中的每条记录。

    主键必须包含唯一的值。
    
    主键不能包含NULL值。
    
    每个表都应该有一个主键，且每个表只能由一个主键。
    
    定义多个列的PRIMARY KEY约束：
    
    ```
    CREATE TABLE tbl_name(
        ...
        CONSTRAINT constraint_name PRIMARY KEY (col_name1,col_name2));
    ```
    撤销PRIMARY KRY约束：
    **MySQL:**
    ```
    ALTER TABLE tbl_name
        DROP PRIMARY KEY;
    ```
    **SQL Server/Oracle/MS Access:**
    ```
    ALTER TABLE tbl_name
        DROP CONSTRAINT constraint_name;
    ```

- **FOREIGN KEY**

    一个表的FOREIGN KEY指向另一个表的UNIQUE KEY。
    
- **CHECK**
    
    CHECK约束用于限制列中的值的范围。

    如果对单个列定义CHECK约束，那么该列只允许特定的值。
    
    如果对一个表定义CHECK约束，那么此约束会给予行中其他列的值在特定的列中对值进行限制。
    
- **DEFAULT**
    
    DEFAULT约束用于向列中插入默认值。
    
    如果没有规定其他的值，那么会将默认值添加到所有的新纪录。

    **修改表时的创建DEFAULT约束：**
    
    MySQL:
    ```
    ALTER TABLE table_name
        ALTER column_name SET DEFAULT default_value;
    ```
    SQL Server/MS Access:
    ```
    ALTER TABLE table_name
        ADD CONSTRAINT constraint_name DEFAULT default_value FOR column_name;
    ```
    
    **撤销DEFAULT约束：**
    
    MySQL：  
    ```
    ALTER TABLE table_name
        ALTER column_name DROP DEFAULT
    ```
    SQL Server/Oracle/MS Access:
    ```
    ALTER TABLE table_name
        ALTER COLUMN column_name DROP DEFAULT
    ```

# SQL CREATE INDEX语句

CREATE INDEX用于在标准创建索引。

在不读取整个表的情况下，索引使数据库应用程序更快地查找数据。

## 创建索引

更新一个包含索引地表需要比更新一个没有索引地表花费更多的时间，这是由于索引本身也需要更新。建议尽在常被搜索的列上创建索引。

使用**CREATE INDEX**创建的索引允许使用重复的值。

使用**CREATE UNIQUE INDEX**创建唯一索引，不允许使用重复的值。

## 撤销索引

**MySQL**
```
ALTER TABLE table_name
    DROP INDEX index_name
```

**DB2/Oracle**

```
DROP INDEX index_name
```

# TRUNCATE TABLE

用于仅删除表内的数据。
    
# SQL AUTO INCREMENT 字段

- **MySQL**

```
CREATE TABLE table_name(
    column_name type AUTO_INCREMENT,
    ...
)
```

- **SQL Server**

```
CREATE TABLE table_name(
    column_name type IDENTITY(start_value,increment_value),
    ...
)
```

- **Access**

```
CREATE TABLE table_name(
    column_name type AUTOINCREMENT,
    ...
)
```

- **Oracle**

Oracle中实现递增必须通过sequence对象。

使用下面的语句创建序列：
```
CREATE SEQUENCE sequence_name
MINVALUE 最小值
START WITH 起始值
INCREMENT BY 递增值
CACHE 缓存值的数量
```

然后在插入新数据时使用nextval函数：
```
INSERT INTO 表名(列名)
    VALUES (序列名.nextval)
```

# SQL 视图

视图是基于SQL语句的结果集的可视化的表。视图包含行和列。视图中的字段来自一个或多个数据库表。

可以向视图添加SQL函数、WHERE以及JOIN语句。

## 创建视图

```
CREATE VIEW 视图名 AS
    SELECT语句
```

## 更新视图

```
CARETE OR REPLACE VIEW 视图名 AS
    SELECT语句
```
# HTTP协议

HTTP协议即超文本传输协议（HyperText Transfer Protocol）是一种用于分布式、协作式和超媒体信息系统的应用层协议，所有WWW文件都必须遵守这个标准。基于TCP/IP通信协议来传递数据。

- HTTP是无连接的。
- HTTP是媒体独立的。
- HTTP是无状态的。

## HTTP消息结构

HTTP是基于C/S的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。

HTTP使用统一资源标识符（Uniform Resource Identifier，URI）来传输数据和建立连接。

### 客户端请求信息

客户端发送一个HTTP请求到服务器的请求消息包含以下格式：请求行（request line）、请求头部（header）、空行和请求数据四部分。

- **请求行**
 
  包含请求方法、URL、协议版本。

- **请求头部**

  包含头部字段名和值的键值对组。

- **请求数据**

  媒体资源。

### 服务器响应信息

  包含状态行、消息报头、空行和响应正文四部分。

## HTTP请求方法

HTTP1.0定义了三种请求方式：GET、POST和HEAD。

HTTP1.1新增了六种请求方式：OPTIONS、PUT、PATCH、DELETE、TRACE和CONNECT。

- **GET**，请求指定的页面信息，并返回实体主体。
- **HEAD**，类似于GET，只不过返回的响应中没有具体的内容，用于获取报头。
- **POST**，向指定资源提交数据进行处理请求。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
- **PUT**，从客户端向服务器传送的数据取代指定的文档的内容。
- **DELETE**，请求服务器删除指定的页面。
- **CONNECT**，HTTP1.1预留给能够将连接改为管道方式的代理服务器。
- **OPTIONS**，允许客户端查看服务器的性能。
- **TRACE**，回显服务器收到的请求，主要用于测试或诊断。
- **PATCH**，是对PUT的补充，用来对已知资源进行局部更新。
  
## HTTP响应头信息

- **Allow**，服务器支持哪些请求方法。
- **Content-Encoding**，文档的编码方法。Servlet通过查看Accept-Encoding头（request.getHeader("Accept-Encoding")）检查浏览器支持的方法。
- **Content-Length**，内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。可以在输出文档修ByteArrayOutputStream，完成后将其长度值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream())发送内容。
- **Content-Type**，表示后面的文档属于MIME类型。
- **Date**，当前的GMT时间。
- **Expires**，应该在什么时候认为文档已经过期。
- **Last-Modified**，文档的最后改动时间。客户可用通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。
- **Location**：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。
- **Refresh**，表示浏览器应该在多少时间之后刷新文档，以秒计。
- **Server**，服务器名字。Servlet一般不设置这个值，而是Web服务器自己设置。
- **Set-Cookie**，设置和页面关联的Cookie。
- **WWW-Authenticate**，表示客户应该在Authorization头中提供什么类型的授权信息。在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader("WWW-Authenticate", "BASIC realm=＼"executives＼"")。
Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。


## HTTP状态码

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。

**响应分为5类：**
- 1xx，信息，服务器收到请求，需要请求者继续执行操作。
- 2xx，成功，操作被成功接收和处理。
- 3xx，重定向，需要进一步的操作以完成请求。
- 4xx，客户端错误，请求包含语法错误或无法完成请求。
- 5xx，服务器错误，服务器在处理请求的过程中发生了错误。

**HTTP状态码列表：**

状态码 | 英文名称 | 描述
--- | --- | ---
100 | Continue | 继续。客户端应继续其请求。
101 | Switching Protocols | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议。
**200** | **OK** | **请求成功。一般用于GET与POST请求。**
201 | Created | 已创建。成功请求并创建了新的资源。
202 |Accepted | 已接受。已经接受请求，但未处理完成。
203 | Non-Authoritative Information | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本。
204 | No Content | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。
205 | Reset Content | 重置内容。服务器处理成功，用户终端应重置文档视图。可通过此返回码清楚浏览器的表单域。
206 | Partial Content | 部分内容。服务器成功处理了部分GET请求。
300 | Multiple Choices | 多种选择。请求的资源可包括多个位置，响应可返回一个资源特征与地址的列表用于用户终端选择。
**301** | **Moved Permanently** | **永久移动。请求的资源已被永久的移动到新的URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。**
302 | Found | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。
303 | See Other | 查看其他地址。与301类似。使用GET和POST请求查看。
304 | Not Modified | 未修改。所请求得资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过得资源，通过提供一个头信息指出客户端希望只返回在指定日期之后得资源。

## HTTP Content-Type

用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。

**常见媒体格式类型：**

- text/html：HTML
- text/plain：纯文本
- text/xml：XML
- image/gif：gif图片
- image/jpeg：jpg图片
- image/png：png图片

**以application开头的媒体格式类型：**

- application/xhtml+xml：XHTML
- application/xml：XML数据
- application/atom+xml：Atom XML聚合
- application/json：JSON数据
- application/pdf：pdf
- application/msword：Word文档
- application/octet-stream：二进制流数据（如常见的文件下载）
- application/x-www-form-urlencoded：被编码为key/value格式的form表单数据

**上传文件时使用的媒体格式：**

- multipart/form-data：表单中上传文件时使用的格式。

