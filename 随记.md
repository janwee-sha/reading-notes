# SQL HAVING子句

在SQL中增加HAVING子句的原因是，WHERE子句关键字无法与聚合函数一起使用，HAVING子句可以让我们筛选分组后的各组数据。

**SQL HAVING 语法**

```
SELECT col_name, aggregate_function(col_name)
FROM tbl_name
WHERE col_name operator value
GROUP BY col_name
HAVING aggregate_function(col_name) operator value;
```

---

# MySQL 字符串函数

- **ASCII(s)**，返回字符串s的第一个字符的ASCII码。
```
SELECT ASCII('Hello');
-- 72
```

- **CHAR_LENGTH(s)**、**CHARACTER_LENGTH(s)**、**LENGTH(s)**，返回字符串s的字符数。
```
SELECT CHAR_LENGTH('Hello');
-- 5
```

- **CONCAT(s1,s2...)**，合并字符串列表(s1,s2...)。
```
SELECT CONCAT('hello',' ','world');
-- hello world
```

- **CONCAT_WS(x,s1,s2...)**， 以x为分隔符合并字符串列表(s1,s2...)
```
SELECT CONCAT_WS(' ','hello','world');
-- hello world
```

- **FIELD(s,s1,s2...)**， 返回第一个字符串s在字符串列表(s1,s2...)中的位置。
```
SELECT FIELD('c','a','b','c','d');
-- 3
```

- **FIND_IN_SET(s1,s2)**， 返回字符串s2中与s1匹配的字符串的位置。
```
SELECT FIND_IN_SET('c','a,b,c,d,e');
-- 3
```

- **FORMAT(x,n)**，将数字x进行格式化，并保留到小数点后n位 。
```
SELECT FORMAT(PI()*10000,2);
-- 31,415.93
```

- **INSERT(s1,x,len,s2)**， 字符串s2替换s1的x位置开始长度为len的字符串。

- **LOCATE(s1,s2)**，从字符串s2中获取s1的开始位置。
```
SELECT LOCATE('christmas','merry christmas');
-- 7
```

- **LCASE(s)**、**LOWER(s)**，小写转换字符串s中的所有字母。 

- **LEFT(s,n)**，返回字符串s的前n个字符。

- **LPAD(s1,len,s2)**，在字符串s1的开始处填充字符串s2，使字符串长度达到len。
```
SELECT LPAD(' world',11,'hello');
-- hello world
```

- **LTRIM(s)**，去掉字符串s开始处的空格。 

-**MID(s,start,len)**、**SUBSTR(s,start,len)**、**SUBSTRING(s,start,len)**，截取子字符串。

---

# MySQL 日期函数

- **ADDDATE(d,INTERVAL expr type)**、**DATE_ADD(d,INTERVAL expr type)**，计算时间表达式d加上区间表达式后的时间。


```
SELECT ADDDATE('2022-02-22 22:22:22',INTERVAL 1 SECOND);
-- 2022-02-22 22:22:23
```

- **ADDTIME(t,n)**，计算时间表达式t加上时间表达式n后的时间。


```
SELECT ADDTIME('2022-02-22 22:22:22',1);
-- 2022-02-22 22:22:23
```

- **CURDATE()**、**CURRENT_DATE()**，返回当前日期。

- **CURRENT_TIME()**、**CURTIME()**，返回当前时间。

- **CURRENT_TIMESTAMP()**，返回当前日期和时间。

- **DATE()**，从日期或日期时间表达式中提起日期值。

- **DATEDIFF(d1，d2)**，计算日期d1->d2之间相隔的天数。
```
SELECT DATEDIFF('2022-1-8 22:15:00','2022-1-9');
-- -1
```

---

# SQL BETWEEN操作符

BETWEEN操作符用于选取介于两个值之间的数据范围内的值。

BETWEEN语法：
```
...col_name BETWEEN value1 AND value2;
```

---

# MySQL OLAP函数

开窗函数（OLAP函数）：为将要被操作的行的集合定义一个窗口，它对一组值进行操作，不需要使用GROUP BY子句对数据进行分组，能够在同一行中同时返回基础行的列和聚合列。

**OLAP的语法结构：**
```
OVER ([PARTITION BY <列清单>] ORDER BY <排序用列清单>)
```

**开窗函数一般分为两类：**

- 能够作为开窗函数的聚合函数，如SUM、AVG、COUNT、MIN。
- 专用开窗函数，如RANK、DENSE、ROW、ROW_NUMBER。

*聚合开窗函数只能使用PARTITION BY子句，ORDER BY不能与聚合开窗函数一同使用。*

---

# SQL FULL OUTER JOIN 关键字

MySQL不支持FULL OUTER JOIN。

---

# SQL SELECT INTO 语句

SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。

MySQL数据库不支持SELECT...INTO语句但支持INSERT INTO...SELECT。

---

# SQL INSERT INTO SELECT语句

INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。

---

# SQL约束

- **NOT NULL**
- **UNIQUE**

    创建表时创建UNIQUE约束：
    ```
    CRAETE TABLE tbl_name(
        col_name type UNIQUE,
        ...);
    ```
    ```
    CRAETE TABLE tbl_name(
        ...,
        UNIQUE(col_name));
    ```
    修改表时在某列上创建UNIQUE约束；
    ```
    ALTER TABLE tbl_name
        ADD UNIQUE (col_name);
    ```
    修改表时定义多个列的UNIQUE约束：
    ```
    ALTER TABLE tbl_name
        ADD CONSTRAINT constraint_name UNIQUE (col_name1,col_name2);
    ```
    撤销UNIQUE约束：
    **MySQL:**
    ```
    ALTER TABLE tbl_name
        DROP INDEX col_name;
    ```
    **SQL Server/Oracle/MS Access:**
    ```
    ALTER TABLE tbl_name
        DROP CONSTRAINT constraint_name;
    ```
    

- **PRIMARY KEY**
    PRIMARY KEY约束唯一标识数据库表中的每条记录。

    主键必须包含唯一的值。
    
    主键不能包含NULL值。
    
    每个表都应该有一个主键，且每个表只能由一个主键。
    
    定义多个列的PRIMARY KEY约束：
    
    ```
    CREATE TABLE tbl_name(
        ...
        CONSTRAINT constraint_name PRIMARY KEY (col_name1,col_name2));
    ```
    撤销PRIMARY KRY约束：
    **MySQL:**
    ```
    ALTER TABLE tbl_name
        DROP PRIMARY KEY;
    ```
    **SQL Server/Oracle/MS Access:**
    ```
    ALTER TABLE tbl_name
        DROP CONSTRAINT constraint_name;
    ```

- **FOREIGN KEY**

    一个表的FOREIGN KEY指向另一个表的UNIQUE KEY。
    
- **CHECK**
    
    CHECK约束用于限制列中的值的范围。

    如果对单个列定义CHECK约束，那么该列只允许特定的值。
    
    如果对一个表定义CHECK约束，那么此约束会给予行中其他列的值在特定的列中对值进行限制。
    
- **DEFAULT**
    
    DEFAULT约束用于向列中插入默认值。
    
    如果没有规定其他的值，那么会将默认值添加到所有的新纪录。

    **修改表时的创建DEFAULT约束：**
    
    MySQL:
    ```
    ALTER TABLE table_name
        ALTER column_name SET DEFAULT default_value;
    ```
    SQL Server/MS Access:
    ```
    ALTER TABLE table_name
        ADD CONSTRAINT constraint_name DEFAULT default_value FOR column_name;
    ```
    
    **撤销DEFAULT约束：**
    
    MySQL：  
    ```
    ALTER TABLE table_name
        ALTER column_name DROP DEFAULT
    ```
    SQL Server/Oracle/MS Access:
    ```
    ALTER TABLE table_name
        ALTER COLUMN column_name DROP DEFAULT
    ```

---

# SQL CREATE INDEX语句

CREATE INDEX用于在标准创建索引。

在不读取整个表的情况下，索引使数据库应用程序更快地查找数据。

## 创建索引

更新一个包含索引地表需要比更新一个没有索引地表花费更多的时间，这是由于索引本身也需要更新。建议尽在常被搜索的列上创建索引。

使用**CREATE INDEX**创建的索引允许使用重复的值。

使用**CREATE UNIQUE INDEX**创建唯一索引，不允许使用重复的值。

## 撤销索引

**MySQL**
```
ALTER TABLE table_name
    DROP INDEX index_name
```

**DB2/Oracle**

```
DROP INDEX index_name
```

---

# TRUNCATE TABLE

用于仅删除表内的数据。

---
    
# SQL AUTO INCREMENT 字段

- **MySQL**

```
CREATE TABLE table_name(
    column_name type AUTO_INCREMENT,
    ...
)
```

- **SQL Server**

```
CREATE TABLE table_name(
    column_name type IDENTITY(start_value,increment_value),
    ...
)
```

- **Access**

```
CREATE TABLE table_name(
    column_name type AUTOINCREMENT,
    ...
)
```

- **Oracle**

Oracle中实现递增必须通过sequence对象。

使用下面的语句创建序列：
```
CREATE SEQUENCE sequence_name
MINVALUE 最小值
START WITH 起始值
INCREMENT BY 递增值
CACHE 缓存值的数量
```

然后在插入新数据时使用nextval函数：
```
INSERT INTO 表名(列名)
    VALUES (序列名.nextval)
```

---

# SQL 视图

视图是基于SQL语句的结果集的可视化的表。视图包含行和列。视图中的字段来自一个或多个数据库表。

可以向视图添加SQL函数、WHERE以及JOIN语句。

## 创建视图

```
CREATE VIEW 视图名 AS
    SELECT语句
```

## 更新视图

```
CARETE OR REPLACE VIEW 视图名 AS
    SELECT语句
```

---

# 容器

## List、Map、Set三个接口存取元素的特点

List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素。Map保存键值对映射。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，基于排序树版本的实现在插入或删除元素时会按照元素或元素的键构成排序树从而达到排序和去重的版本。

## HashMap和Hashtable的区别

- HashMap允许键和值都是null，Hashtable不允许键或值是null。
- Hashtable是同步的，而HashMap不是。
- HashMap提供了可供应用迭代的键的集合，因此是快速失败的。Hashable提供了对键的列举（Enumeration）。

## 快速失败和安全失败

### 快速失败（fail-fast）

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改，则会抛出Concurrent Modification Exception。

**原理**：迭代器在遍历时直接访问集合中的内容，并且在遍历工程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用探测或遍历下一个元素之前，都会检测modCount是否等于exceptedModCount，是则返回结果；否则抛出异常。

**场景**：java.util包下的集合类都是快速失败的，不能再多线程下发生并发修改。

### 安全失败(fail-safe)

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

**场景**：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

## 集合类为什么没有实现Cloneable和Serializable接口

克隆和序列化的语义跟具体的实现相关，因此应该由集合类的具体实现决定如何被克隆或者是序列化。

# Spring

## 依赖注入

Spring框架的核心功能有两个：

- Spring容器负责创建并管理所有的java对象，这些对象被称为Bean。
- Spring容器管理容器中Bean之间的依赖关系，Spring使用“依赖注入”的方式来管理Bean之间的依赖关系。

依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。

以配置文件来管理Java实例的协作关系的方式被Rod Johnson称作控制反转（Inverse of Control），被Martin Fowler称作依赖注入（Dependency Injection）。

### 设值注入与构造注入的对比

设值注入的优点：

---

# 布隆过滤器

是由一个很长的二进制向量和一系列随机映射函数组成，布隆过滤器可以用于检索一个元素是否在一个集合中。

## 布隆过滤器的数据结构

布隆过滤器是一个bit数组（也称为bit向量）。

初始时所有bit位置的值都为0。如果需要映射一个值到布隆过滤器，我们需要使用**多个不同的哈希函数**生成**多个哈希值**，并将每个生成的哈希值指向的bit位置的值置为1；当查询某个值是否存在时，使用哈希函数生成多个值，并判断是否所有生成的哈希值指向的bit位置的值是否都为1，是则可能存在查询的值，否则一定不存在查询的值。

## 优点

- 空间效率和查询时间都远远超过一般的算法。

## 缺点

- 返回的结果是概率性的，而不是确切的。只可以告诉你某样东西一定不存在或者可能存在。
- 删除元素很困难。如果把位列阵变成整数数组，没插入一个元素相应的计数器加1，每删除一个元素相应的计数器减1，我们必须保证删除的元素的确在布隆过滤器里面，这一点单凭这个过滤器是无法保证的。

## 如何选择哈希函数个数和布隆过滤器长度

过小的布隆过滤器很快所有的bit位都会变为1，起不到过滤的目的。长度会直接影响误报率，越长其误报率越小。

哈希函数的个数也需要权衡，个数越多则bit位置置为1的速度越快，且布隆过滤器的效率越低；太少则误报率越高。

---

# 散列表

散列表（Hash table，也叫哈希表），是根据关键码值而直接进行访问的数据结构。散列表通过把关键码值映射到一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

使用散列的查找算法分为两步：

1.用**散列函数**将被查找的键转化为数组的一个索引。
2.**处理碰撞冲突**。

## 散列函数

散列函数和键的类型有关。严格地说，**对于每种类型地键我们都需要一个与之对应地散列函数**。

优秀的散列方法需要满足的条件：
- **一致性**——等价的键必然产生相等的散列值；
- **均匀性**——均匀的散列所有的键；
- **高效性**——计算简便。

### 正整数

将整数散列地最常用方法是**除留取余法**。我们选择大小为素数M的数组，计算k初一M的余数。

### 浮点数

如果键是0到1之间的实数，可以将它与M相乘的结果表示为二进制数然后再使用除留取余法。

### 字符串

除留取余法也可以处理较长的键，例如字符串，我们只需要将它们当作大整数即可。

如：

```
int hash = 0;
for (int i=0; i<s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M;
```

### 组合键

如果键的类型包含多个整数值，我们可以和String类型一样将它们混合起来。

### 将hashCode转化为一个数组索引

Java默认的hashCode会产生一个32位的整数，我们在实现散列表时可以将hashCode和除留余数法产生一个0到M-1的整数。

```
private int hash(K x){
    return (x.hashCode() & 0x7fffffff)%M;
}
```

## 直接寻址表

取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key)=a*key+b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key)中已经有值了，就往下一个找，直到H(key)中没有值了。

当关键字的全域U比较小时，直接寻址是一种简单而有效的技术。

---
# 查找树

## 二叉查找树

定义：一棵**二叉查找树**（BST）是一个二叉树，其中每个节点都含有一个Comparable的键（以及相关联的值）且每个节点的键都大于其左子树中的任一节点的键而小于右子树的任意节点的键。

使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被先后插入的顺序。在最好的情况下，每条空链接和根节点的距离都为~lgN。在最坏的情况下，搜索路径上可能有N个节点。

## 平衡查找树

### 2-3查找树

一棵2-3查找树或为一棵空树，或由以下结点组成：

- 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树都大于该结点。
- 3-结点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树都位于该结点的两个键之间，右链接指向的2-3树都大于该结点。

**查找**：先将要查找的键与根节点中的键作比较，如果它与任意一个相等，查找命中；否则根据比较的结果找到指向相应区间的链接，并在子树中递归地继续查找。

**插入**：查找命中，更新结点的值；查找未命中，若未命中的查找结束（查找到树的底部）于一个2-结点，把这个2-结点替换为一个3-结点。若未命中的查找结束于一个3-结点，

### AVL树

### 红黑二叉查找树

用标准二叉树和一些额外的信息（替换3-结点）来表示2-3树。

树的链接分为两种类型：**红链接**将两个2-结点连接起来构成一个3-链接，**黑链接**则是2-3树中的普通链接。

一种等价的定义：

红黑树是含有红黑链接并满足下列条件的二叉查找树：

- 红链接均为左链接；
- 没有任何一个结点同时和两条红链接相连；
- 该树是**完美黑色平衡**的，即任意空链接到根结点路径上的黑链接数量相等。

红黑树既是二叉查找树，又是2-3树。

## B-Tree

多路搜索树。使用B-Tree可以显著减少定位记录所经历的中间过程，从而加快存取速度。

---

# Java ClassLoader

ClassLoader是Java的类型加载器，ClassLoader是一个抽象类。ClassLoader负责通过给定的类的二进制名称来定位或生成类的数据。一个典型的策略是将二进制名称转换成文件名然后到文件系统中找到该文件。

Java中的类大致分为三种：

- 系统类
- 拓展类
- 客户自定义类

类装载方式分为两种：

- 隐式装载，程序在运行过程中当碰到通过`new`等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。
- 显式装在，通过`Class.forName()`等方法，显式加载需要的类。

Java装载类使用“全盘负责委托机制”。“全盘负责”是指当一个`ClassLoader`装载一个类时，除非显式地使用另外一个`ClassLoader`，该类所依赖及引用地类也由这个`ClassLoader`载入；“委托机制”是指先委托弗雷装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。

类装载器就是寻找类或接口字节码文件进行解析并构造JVM内部对象表示的组件，有以下步骤：

1. 装载：查找和导入Class文件
2. 链接：


---

HTTPS如何保证数据传输的安全性

数据传输手段：
1. 明文传输
2. 对称加密
3. 非对称加密